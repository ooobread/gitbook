# BasicKnowledge

## 整数数据类型
* short至少16位；int至少与short一样长；long至少32位，且至少与int一样长；long long至少64位，且至少与long一样长。
* bool类型中，true可以被转换为1，false可以被转换为0

## 浮点数
* 两种书写方法：
  * 标准小数点法：12.34，0.00023
  * E表示法：3.45E6，即3.45乘以10的6次方的结果。
* C++的3种浮点类型：`float`, `double`, `long double`是按照它们可以表示的有效数位和允许的指数最小范围来描述的。
* 对有效数位的要求：`float`至少32位；`double`至少64位，且不少于`float`；`long double`至少和`double`一样多。
* 指定浮点类型：
  * 默认情况下，12.34、3.45E6这样的浮点常量都属于`double`。
  * 使用`1.234f`格式来存储`float`类型浮点数。
  * 使用`1.234l`格式来存储`long double`类型浮点数。

## 数据类型转换
* 列表初始化不允许收窄转换，例如浮点数转为整型数。
* 通常来说`long`或者`long long`可能可以被转换为`int`，这取决于类型转换的目标变量能否容纳被转换的变量类型，例如`int a = (long)123`是合法的，但在**列表初始化**中，由于被转换的是变量，因此编译器无法确定转换的目标变量是否可以容纳，因此不合法。

## 表达式中的类型转换
* `bool`, `char`, `unsigned char`, `signed char`, `short`将被转换为`int`，这被称为**整型提升**。
* 如果`short`变量的长度小于`int`，则`unsigned short`将被转换为`int`，如果`short`变量的长度等于`int`，则`unsigned short`将被转换为`unsigned int`来防止数据损失。
* 当不同类型数据进行算数运算时，较小的类型将被转换为较大的类型，例如`9.0/5`，5将被转换为`double`再进行计算。
* C++通过校验表来确定表达式中数据类型的转换，C++11的校验表如下（按照执行优先级排列）：
  1. 若有一个操作数为`long double`，则将另一个操作数转换为`long double`；
  2. 若有一个操作数为`double`，则将另一个操作数转换为`double`；
  3. 若有一个操作数为`float`，则将另一个操作数转换为`float`；
  4. 若操作数均为整型，则先运用整型提升（`char`和`short`先被转换为`int`）；
  5. 若两个操作数均为有符号或无符号，则将低级别类型操作数转换为高级别类型；
  6. 若一个操作数为有符号，一个操作数为无符号，且无符号操作数类型级别高于有符号操作数，则将有符号操作数类型转换为无符号操作数所属的类型；
  7. 若有符号类型可以表示无符号类型的所有可能取值，则将无符号操作数类型转换为有符号操作数所属类型；
  8. 将两个操作数均转换为有符号类型无符号版本。

## 传参中的类型转换
* C++传参中的类型转换由函数原型控制，若没有函数原型控制，则遵循整型提升。其中为了与C兼容，在没有函数原型控制的情况下，`float`将被优先转换为`double`。

## 数组
* 数组初始化规则：
  * 只有在定义数组时才能初始化，`int arr[3] = {1, 2, 3}`
  * 如果只对数组一部分初始化，则编译器将其他元素设置为0。
  * 如果采用类似`int arr[] = {1, 2, 3}`，编译器将自动计算元素数量。例如前面的例子中元素数量为3。
  * C++11中可以使用列表初始化来初始化数组，其特点如下：
    * 初始化数组时可省略等号：`int arr[3] {1, 2, 3}`
    * 当大括号内没有东西时，将所有元素置为0：`int arr[3] {}`
    * 使用列表初始化来初始化数组时，禁止收窄转换。

## 联合体
* 其中所有变量共用起始内存

## 命名空间
* 命名空间中声明的名称的链接性为外部的（除非他引用了常量）。
* 命名空间是开放的，可以把名称添加到已有的命名空间中；也可以将声明与实现写在同名的命名空间中。正是因为这一点，多个文件中的命名空间不会发生冲突。

## 存储持续性、作用域与链接性
### 存储持续性
* 自动存储持续性：
  * 函数定义中声明的变量，在函数执行时创建，函数执行结束时释放。
  * 自动变量通过栈的方式管理内存的申请与释放。
* 静态存储持续性：在函数外定义的变量和`static`所修饰的变量，生命周期为整个程序运行周期。
* 动态存储持续性：由`new`所分配，由`delete`或程序结束时所销毁。
* 线程存储持续性（C++11）：使用`thread_local`声明的变量，声明周期与线程相同。

### 作用域与链接性
* 作用域描述了名称在多大范围内可见。
* 链接性描述了名称如何在文件中共享：
  * 链接性为外部意味着可以在文件之间共享。
  * 链接性为内部意味着仅能在一个文件中的函数共享。
  * 自动变量的名称没有链接性，因为他们不能被共享。
* 当出现同样名称但不同作用域的变量时，新的变量名称将会“隐藏”旧的变量名称，直到程序执行超出了新变量名称的作用域。
* 静态持续变量：
  * 同样具有外部、内部、无链接性这三种链接性类型，编译器分配固定内存来存放静态变量。
  * 若没有显式初始化，静态变量将被初始化为0，静态数组的每个成员也将被初始化为0.
  * 创建不同链接性静态变量的方法：
    ```cpp
    int global = 100; // 静态变量，变量具有外部链接性
    static int one_file = 50; // 静态变量，变量具有内部链接性

    void func()
    {
      static int n = 0; // 静态变量，变量无链接性
    }
    ```
* 引用定义：
  * 单定义规则：简单来说，在相同的作用域中，同样名称的变量只能被定义一次。
    ```cpp
    // file1
    int errors = 20; // 全局变量
    ```
    ```cpp
    // file2
    #include <iostream>
    using namespace std;

    // int errors = 30; 将会产生编译错误，重复定义
    extern int errors; // 如果需要使用全局版本的errors，需要使用extern关键字进行引用定义
    static int errors = 30; // 编译通过，通过static关键字将变量作用域限制在文件中，与file1中的errors变量已不在相同的作用域中。需要注意的是，这个变量在这个文件中已将file1中的全局变量errors隐藏，若需要使用全局版本的errors，我们在C++中可以使用::操作符。

    int main()
    {
      cout << errors << endl; // 30
      cout << ::errors << endl; // 20
    }
    ```
  * 当一个静态变量具有外部链接性，需要在其他文件中被使用（因此需要在该文件中进行定义），但又受限于**单定义规则**变量只能被定义一次的时候，一种方法为使用**引用定义**来定义该变量，这种定义方法并不分配存储空间。相对应的，另外一种分配存储空间的定义方式被称为**定义声明**或者简称为**定义**。
  * 其使用方法为使用`extern`关键字，且不进行初始化，否则变量将被视为**定义**，被分配存储空间：
    ```cpp
    int def = 0; // 定义，分配存储空间
    extern int ex_def; // 引用定义，ex_def在别处定义，此处不分配存储空间
    extern int not_ex_def = 0; // 定义，因为进行了初始化，进行了存储空间分配
    ```
    